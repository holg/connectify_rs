// --- File: crates/connectify_payrexx/src/logic.rs ---

use chrono::Utc;
use connectify_config::PayrexxConfig; // Use config types
use once_cell::sync::Lazy;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use thiserror::Error;

// --- Error Handling ---
#[derive(Error, Debug)]
pub enum PayrexxError {
    #[error("Payrexx API request failed: {0}")]
    RequestError(#[from] reqwest::Error),
    #[error("Payrexx API returned an error: Status={status}, Message='{message}'")]
    ApiError { status: String, message: String },
    #[error("Failed to parse Payrexx API response: {0}")]
    ParseError(#[from] serde_json::Error),
    #[error("Payrexx configuration missing or incomplete")]
    ConfigError,
    #[error("Webhook signature verification failed")] // Added Webhook Error
    WebhookSignatureError,
    #[error("Webhook processing error: {0}")] // Added Webhook Error
    WebhookProcessingError(String),
    #[error("Internal processing error: {0}")]
    InternalError(String),
}

// --- Static HTTP Client ---
// Initialize reqwest client lazily and store it statically
// This client will be reused for all Payrexx API calls within this crate
static HTTP_CLIENT: Lazy<Client> = Lazy::new(Client::new);

// --- Data Structures ---

// Request from our frontend to create gateway
#[derive(Deserialize, Serialize, Debug)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct CreateGatewayRequest {
    pub amount_override: Option<i64>,
    pub currency_override: Option<String>,
    pub purpose_override: Option<String>,
    pub user_email: Option<String>,
}

// Payload sent TO Payrexx API
#[derive(Serialize, Deserialize, Debug)]
struct PayrexxApiRequest<'a> {
    amount: i64, // Payrexx expects amount in cents/rappen as integer
    currency: &'a str,
    purpose: &'a str,
    #[serde(rename = "referenceId")]
    reference_id: String, // Generate a unique reference
    #[serde(rename = "successRedirectUrl")]
    success_redirect_url: String,
    #[serde(rename = "failedRedirectUrl")]
    failed_redirect_url: String,
    #[serde(rename = "cancelRedirectUrl")]
    cancel_redirect_url: String,
    // Optional: Add customer email field if provided
    #[serde(skip_serializing_if = "Option::is_none")]
    fields: Option<PayrexxFields>,
    // Add other optional fields like 'psp', 'pm' if needed
}

// Optional fields to send to Payrexx (like customer email)
// Optional fields to send to Payrexx (like customer email)
#[derive(Serialize, Deserialize, Debug)]
struct PayrexxFields {
    #[serde(skip_serializing_if = "Option::is_none")]
    email: Option<PayrexxEmailField>,
    // Add other fields like firstname, lastname etc. if needed
}


#[derive(Serialize, Deserialize, Debug)]
struct PayrexxEmailField {
    value: String,
}


// Response FROM Payrexx API (Gateway Creation)
#[derive(Deserialize, Serialize, Debug)]
struct PayrexxApiResponseData {
    // id: i32, // Usually present but maybe not needed
    // hash: String, // Usually present but maybe not needed
    /// The payment link URL generated by Payrexx.
    link: String,
    // Add other fields if needed
}

/// Represents the overall structure of the Payrexx API response (success or error).
#[derive(Deserialize, Serialize, Debug)]
struct PayrexxApiResponse {
    status: String,
    /// Payrexx returns the gateway data within an array on success.
    #[serde(default)] // Use default (empty vec) if 'data' is missing (e.g., in error response)
    data: Vec<PayrexxApiResponseData>,
    message: Option<String>, // Capture potential error messages
}

// Response sent back TO our frontend
#[derive(Serialize, Deserialize, Debug)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct CreateGatewayResponse {
    /// The URL for the Payrexx payment page.
    pub url: String,
}

// --- NEW: Webhook Payload Structures ---
// NOTE: These are examples based on common patterns.
//       Verify exact field names and types with Payrexx documentation!

#[derive(Deserialize, Serialize, Debug, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct PayrexxWebhookTransaction {
    pub id: Option<i64>,        // Payrexx Transaction ID
    pub status: Option<String>, // e.g., "waiting", "confirmed", "cancelled", "failed"
    #[serde(rename = "referenceId")] // Match potential camelCase from Payrexx
    pub reference_id: Option<String>, // The referenceId you sent when creating gateway
    pub amount: Option<i64>,    // Amount in cents/rappen
    pub currency: Option<String>,
    // Add other relevant fields like invoice details, customer info, timestamps etc.
}

#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct PayrexxWebhookPayload {
    // Payrexx might nest the transaction data
    pub transaction: Option<PayrexxWebhookTransaction>,
    // Add other top-level webhook fields if any
    #[serde(rename = "type")] // Example: event type if provided
    pub event_type: Option<String>,
}

// --- Core Logic Functions ---

// create_gateway_request function remains the same
pub async fn create_gateway_request(
    config: &PayrexxConfig,
    request_data: CreateGatewayRequest,
) -> Result<CreateGatewayResponse, PayrexxError> {
    println!("Initiating Payrexx gateway creation...");

    // Determine final values, using overrides or defaults from config
    let amount = request_data
        .amount_override
        .unwrap_or(config.unit_amount.unwrap_or(1000));
    let currency = request_data
        .currency_override
        .as_deref()
        .unwrap_or(&config.currency.as_deref().unwrap_or("CHF"));
    let purpose = request_data
        .purpose_override
        .as_deref()
        .unwrap_or(&config.product_name.as_deref().unwrap_or("Payment"));

    // Generate a unique reference ID for this transaction
    let reference_id = format!(
        "connectify-{}-{}",
        SERVICE_NAME,
        Utc::now().timestamp_millis()
    ); // Use const SERVICE_NAME

    // Construct Payrexx API payload
    let api_payload = PayrexxApiRequest {
        amount,
        currency,
        purpose,
        reference_id,
        success_redirect_url: config.success_url.clone(),
        failed_redirect_url: config.failed_url.clone(),
        cancel_redirect_url: config.cancel_url.clone(),
        fields: request_data
            .user_email
            .as_deref()
            .map(|email| PayrexxFields {
                email: Some(PayrexxEmailField { value: email.to_string() }),
            }),
    };

    // Construct Payrexx API URL
    let api_url = format!(
        "https://api.payrexx.com/v1.0/Gateway/?instance={}",
        config.instance_name
    );

    println!("Sending request to Payrexx API: {}", api_url);

    // --- Make the API Call ---
    // Get API Secret securely from environment
    let api_secret = std::env::var("PAYREXX_API_SECRET").map_err(|_| PayrexxError::ConfigError)?;

    // Use the static HTTP_CLIENT
    let response = HTTP_CLIENT // Use the static client directly
        .post(&api_url)
        .header("Api-Secret", api_secret) // Use Api-Secret header (check Payrexx docs)
        .header(reqwest::header::CONTENT_TYPE, "application/json")
        .json(&api_payload)
        .send()
        .await?; // Propagates reqwest::Error as PayrexxError::RequestError

    let status = response.status();
    let body_text = response.text().await?; // Read body text once

    println!("Payrexx API response status: {}", status);

    // --- Parse Response ---
    if status.is_success() {
        let payrexx_response: PayrexxApiResponse = serde_json::from_str(&body_text)?; // Propagates ParseError

        if payrexx_response.status == "success" {
            // Extract link from the first element in the data array
            if let Some(gateway_data) = payrexx_response.data.first() {
                println!(
                    "Payrexx gateway created successfully. Link: {}",
                    gateway_data.link
                );
                Ok(CreateGatewayResponse {
                    url: gateway_data.link.clone(),
                })
            } else {
                eprintln!("Payrexx API success status but missing data/link in response.");
                Err(PayrexxError::InternalError(
                    "Payrexx response missing gateway link".to_string(),
                ))
            }
        } else {
            // API returned success HTTP status but error status in JSON body
            let error_message = payrexx_response
                .message
                .unwrap_or_else(|| "Unknown Payrexx API error".to_string());
            eprintln!(
                "Payrexx API reported error. Status: {}, Message: {}",
                payrexx_response.status, error_message
            );
            Err(PayrexxError::ApiError {
                status: payrexx_response.status,
                message: error_message,
            })
        }
    } else {
        // HTTP request itself failed
        eprintln!(
            "Payrexx API request failed with HTTP status: {}. Body: {}",
            status, body_text
        );
        Err(PayrexxError::ApiError {
            status: status.to_string(),
            message: body_text,
        })
    }
}

// --- NEW: Webhook Processing Logic ---

/// Verifies the signature of an incoming Payrexx webhook request.
/// Placeholder implementation - requires details from Payrexx documentation.
pub fn verify_payrexx_signature(
    _api_secret: &str,               // The API secret used for signing
    _request_body: &[u8],            // The raw request body bytes
    _signature_header: Option<&str>, // The value from the Payrexx signature header
) -> Result<(), PayrexxError> {
    // TODO: Implement actual signature verification based on Payrexx docs.
    // This typically involves HMAC-SHA256 or similar.

    println!("⚠️ WARNING: Payrexx webhook signature verification is NOT implemented!");
    // For now, always return Ok - THIS IS INSECURE FOR PRODUCTION
    Ok(())
    // Example failure:
    // Err(PayrexxError::WebhookSignatureError)
}

/// Processes a verified Payrexx webhook payload.
pub async fn process_webhook(
    payload: PayrexxWebhookPayload,
    // Add other dependencies if needed (e.g., database access, GCal client)
    // db_pool: &SqlitePool,
) -> Result<(), PayrexxError> {
    println!("Processing webhook event type: {:?}", payload.event_type);

    if let Some(transaction) = payload.transaction {
        println!(
            "Transaction ID: {:?}, Status: {:?}",
            transaction.id, transaction.status
        );

        // Handle based on transaction status
        match transaction.status.as_deref() {
            Some("confirmed") => {
                println!(
                    "✅ Payment confirmed for reference: {:?}",
                    transaction.reference_id
                );
                // TODO: Implement actions for successful payment:
                // 1. Look up order/booking using transaction.referenceId in your DB.
                // 2. Mark order as paid.
                // 3. Trigger GCal booking if linked via referenceId.
                // 4. Send confirmation email, etc.
            }
            Some("waiting") => {
                println!("⏳ Payment waiting for confirmation.");
                // Usually no action needed, wait for 'confirmed' or 'failed'/'cancelled'.
            }
            Some("cancelled") => {
                println!(
                    "❌ Payment cancelled for reference: {:?}",
                    transaction.reference_id
                );
                // TODO: Update order status if needed.
            }
            Some("failed") => {
                println!(
                    "❌ Payment failed for reference: {:?}",
                    transaction.reference_id
                );
                // TODO: Update order status if needed.
            }
            Some(other_status) => {
                println!("ℹ️ Received unhandled transaction status: {}", other_status);
            }
            None => {
                println!("⚠️ Webhook received without transaction status.");
            }
        }
    } else {
        println!("⚠️ Webhook received without transaction data.");
    }

    // Return Ok(()) to indicate successful processing (even if no action taken for certain statuses)
    Ok(())
}

// Placeholder for service name or better reference ID generation
const SERVICE_NAME: &str = "connectify_payrexx";
